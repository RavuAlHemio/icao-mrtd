//! The Diffie-Hellman secret exchange process.


pub mod params;


use crypto_bigint::{BoxedUint, NonZero};
use crypto_bigint::modular::{BoxedMontyForm, BoxedMontyParams};
use zeroize::Zeroizing;
use zeroize_derive::ZeroizeOnDrop;


#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, ZeroizeOnDrop)]
pub struct DiffieHellmanParams {
    /// The prime or modulus.
    prime: BoxedUint,

    /// The generator or base.
    generator: BoxedUint,

    /// The size of the subgroup generated by these parameters.
    subgroup_size: BoxedUint,
}
impl DiffieHellmanParams {
    /// Returns a reference to the prime or modulus.
    pub fn prime(&self) -> &BoxedUint { &self.prime }

    /// Returns a reference to the generator or base.
    pub fn generator(&self) -> &BoxedUint { &self.generator }

    /// Returns a reference to the subgroup size.
    pub fn subgroup_size(&self) -> &BoxedUint { &self.subgroup_size }

    /// Returns the size of the subgroup generated by these parameters, in bytes.
    ///
    /// Hints at the recommended size of private keys.
    pub fn subgroup_size_bytes(&self) -> usize {
        let bits = self.subgroup_size.bits();
        let mut bytes = bits / 8;
        if bits % 8 != 0 {
            bytes += 1;
        }
        usize::try_from(bytes).unwrap()
    }

    /// Creates new Diffie-Hellman parameters structure with the given prime, generator, and
    /// subgroup size.
    pub fn new(prime: BoxedUint, generator: BoxedUint, subgroup_size: BoxedUint) -> Self {
        Self { prime, generator, subgroup_size }
    }

    /// Calculates a public key from a private key.
    pub fn calculate_public_key(&self, private_key: &BoxedUint) -> Zeroizing<BoxedUint> {
        // pubkey = generator ** private_key mod prime
        let monty_params = BoxedMontyParams::new(self.prime.to_odd().unwrap());
        let monty_generator = BoxedMontyForm::new(self.generator.clone(), monty_params);
        let public_key = monty_generator.pow(private_key).retrieve();
        Zeroizing::new(public_key)
    }

    /// Derives a secret key from the private key and the other party's public key.
    pub fn diffie_hellman(&self, private_key: &BoxedUint, other_public_key: &BoxedUint) -> Zeroizing<BoxedUint> {
        // secret = other_public_key ** private_key mod prime
        let monty_params = BoxedMontyParams::new(self.prime.to_odd().unwrap());
        let monty_other_public = BoxedMontyForm::new(other_public_key.clone(), monty_params);
        let secret = monty_other_public.pow(private_key).retrieve();
        Zeroizing::new(secret)
    }

    /// Derives new Diffie-Hellman parameters using generic mapping with the given nonce and shared
    /// secret.
    ///
    /// With generic mapping, `prime` and `subgroup_size_bytes` stay the same; the new `generator` is calculated thus:
    /// ```plain
    /// new_generator = (self.generator ** nonce) * shared_secret
    /// ```
    pub fn derive_generic_mapping(&self, nonce: &BoxedUint, shared_secret: &BoxedUint) -> Self {
        let monty_params = BoxedMontyParams::new(self.prime().to_odd().unwrap());
        let generator_monty = BoxedMontyForm::new(self.generator().clone(), monty_params.clone());
        let shared_secret_monty = BoxedMontyForm::new(shared_secret.clone(), monty_params.clone());

        let new_generator_monty = generator_monty.pow(nonce).mul(&shared_secret_monty);
        let new_generator = new_generator_monty.retrieve();
        Self::new(self.prime().clone(), new_generator, self.subgroup_size().clone())
    }

    /// Derives a new generator using integrated mapping from the given pseudorandom function result.
    pub fn derive_integrated_mapping_generator(&self, pseudorandom_result: &BoxedUint) -> Zeroizing<BoxedUint> {
        let one = BoxedUint::one().widen(self.prime().bits());
        let prime_minus_one = self.prime() - &one;
        let bit_count = prime_minus_one.bits().max(self.subgroup_size().bits());
        let a = prime_minus_one.widen(bit_count) / NonZero::new(self.subgroup_size().widen(bit_count)).unwrap();

        let monty_params = BoxedMontyParams::new(self.prime().to_odd().unwrap());
        let pseudorandom_monty = BoxedMontyForm::new(pseudorandom_result.clone(), monty_params.clone());
        let one_monty = BoxedMontyForm::new(one.clone(), monty_params.clone());

        let ret = pseudorandom_monty.pow(&a);
        assert_ne!(&ret, &one_monty);
        Zeroizing::new(ret.retrieve())
    }
}


#[cfg(test)]
mod tests {
    use super::DiffieHellmanParams;
    use crypto_bigint::BoxedUint;
    use hex_literal::hex;
    use crate::crypt::boxed_uint_from_be_slice;

    #[test]
    fn wikipedia_example() {
        let prime = BoxedUint::from(23u8);
        let generator = BoxedUint::from(5u8);
        let dh_params = DiffieHellmanParams::new(prime.clone(), generator.clone(), prime.clone());

        let alice_private = BoxedUint::from(4u8);
        let bob_private = BoxedUint::from(3u8);

        let alice_public = dh_params.calculate_public_key(&alice_private);
        assert_eq!(&*alice_public, &BoxedUint::from(4u8));
        let bob_public = dh_params.calculate_public_key(&bob_private);
        assert_eq!(&*bob_public, &BoxedUint::from(10u8));

        let alice_secret = dh_params.diffie_hellman(&alice_private, &bob_public);
        let bob_secret = dh_params.diffie_hellman(&bob_private, &alice_public);
        assert_eq!(alice_secret, bob_secret);
        assert_eq!(&*alice_secret, &BoxedUint::from(18u8));
        assert_eq!(&*bob_secret, &BoxedUint::from(18u8));
    }

    #[test]
    fn icao_doc9303_part11_secg2_example() {
        // classic Diffie-Hellman
        // this is "1024-bit MODP Group with 160-bit Prime Order Subgroup" from RFC5114
        let prime = boxed_uint_from_be_slice(&hex!("
            B10B8F96 A080E01D DE92DE5E AE5D54EC
            52C99FBC FB06A3C6 9A6A9DCA 52D23B61
            6073E286 75A23D18 9838EF1E 2EE652C0
            13ECB4AE A9061123 24975C3C D49B83BF
            ACCBDD7D 90C4BD70 98488E9C 219A7372
            4EFFD6FA E5644738 FAA31A4F F55BCCC0
            A151AF5F 0DC8B4BD 45BF37DF 365C1A65
            E68CFDA7 6D4DA708 DF1FB2BC 2E4A4371
        "));
        let generator = boxed_uint_from_be_slice(&hex!("
            A4D1CBD5 C3FD3412 6765A442 EFB99905
            F8104DD2 58AC507F D6406CFF 14266D31
            266FEA1E 5C41564B 777E690F 5504F213
            160217B4 B01B886A 5E91547F 9E2749F4
            D7FBD7D3 B9A92EE1 909D0D22 63F80A76
            A6A24C08 7A091F53 1DBF0A01 69B6A28A
            D662A4D1 8E73AFA3 2D779D59 18D08BC8
            858F4DCE F97C2A24 855E6EEB 22B3B2E5
        "));
        let subgroup_size = boxed_uint_from_be_slice(&hex!("
            F518AA87 81A8DF27 8ABA4E7D 64B7CB9D 49462353
        "));
        let dh_params = DiffieHellmanParams::new(prime.clone(), generator.clone(), subgroup_size.clone());

        let terminal_private = boxed_uint_from_be_slice(&hex!("
            5265030F 751F4AD1 8B08AC56 5FC7AC95 2E41618D
        "));
        let chip_private = boxed_uint_from_be_slice(&hex!("
            66DDAFEA C1609CB5 B963BB0C B3FF8B3E 047F336C
        "));

        let terminal_public = dh_params.calculate_public_key(&terminal_private);
        assert_eq!(
            &*terminal_public,
            &boxed_uint_from_be_slice(&hex!("
                23FB3749 EA030D2A 25B278D2 A562047A
                DE3F01B7 4F17A154 02CB7352 CA7D2B3E
                B71C343D B13D1DEB CE9A3666 DBCFC920
                B49174A6 02CB4796 5CAA73DC 702489A4
                4D41DB91 4DE9613D C5E98C94 160551C0
                DF86274B 9359BC04 90D01B03 AD54022D
                CB4F57FA D6322497 D7A1E28D 46710F46
                1AFE710F BBBC5F8B A166F431 1975EC6C
            ")),
        );
        let chip_public = dh_params.calculate_public_key(&chip_private);
        assert_eq!(
            &*chip_public,
            &boxed_uint_from_be_slice(&hex!("
                78879F57 225AA808 0D52ED0F C890A4B2
                5336F699 AA89A2D3 A189654A F70729E6
                23EA5738 B26381E4 DA19E004 706FACE7
                B235C2DB F2F38748 312F3C98 C2DD4882
                A41947B3 24AA1259 AC22579D B93F7085
                655AF308 89DBB845 D9E6783F E42C9F24
                49400306 254C8AE8 EE9DD812 A804C0B6
                6E8CAFC1 4F84D825 8950A91B 44126EE6
            ")),
        );

        let terminal_secret = dh_params.diffie_hellman(&terminal_private, &chip_public);
        let chip_secret = dh_params.diffie_hellman(&chip_private, &terminal_public);
        let shared_secret = boxed_uint_from_be_slice(&hex!("
            5BABEBEF 5B74E5BA 94B5C063 FDA15F1F
            1CDE9487 3EE0A5D3 A2FCAB49 F258D07F
            544F13CB 66658C3A FEE9E727 389BE3F6
            CBBBD321 28A8C21D D6EEA3CF 7091CDDF
            B08B8D00 7D40318D CCA4FFBF 51208790
            FB4BD111 E5A968ED 6B6F08B2 6CA87C41
            0B3CE0C3 10CE104E ABD16629 AA48620C
            1279270C B0750C0D 37C57FFF E302AE7F
        "));
        assert_eq!(terminal_secret, chip_secret);
        assert_eq!(&*terminal_secret, &shared_secret);
        assert_eq!(&*chip_secret, &shared_secret);
    }

    #[test]
    fn icao_doc9303_part11_sech2_example() {
        // classic Diffie-Hellman
        // this is "1024-bit MODP Group with 160-bit Prime Order Subgroup" from RFC5114
        let prime = boxed_uint_from_be_slice(&hex!("
            B10B8F96 A080E01D DE92DE5E AE5D54EC
            52C99FBC FB06A3C6 9A6A9DCA 52D23B61
            6073E286 75A23D18 9838EF1E 2EE652C0
            13ECB4AE A9061123 24975C3C D49B83BF
            ACCBDD7D 90C4BD70 98488E9C 219A7372
            4EFFD6FA E5644738 FAA31A4F F55BCCC0
            A151AF5F 0DC8B4BD 45BF37DF 365C1A65
            E68CFDA7 6D4DA708 DF1FB2BC 2E4A4371
        "));
        let generator = boxed_uint_from_be_slice(&hex!("
            A4D1CBD5 C3FD3412 6765A442 EFB99905
            F8104DD2 58AC507F D6406CFF 14266D31
            266FEA1E 5C41564B 777E690F 5504F213
            160217B4 B01B886A 5E91547F 9E2749F4
            D7FBD7D3 B9A92EE1 909D0D22 63F80A76
            A6A24C08 7A091F53 1DBF0A01 69B6A28A
            D662A4D1 8E73AFA3 2D779D59 18D08BC8
            858F4DCE F97C2A24 855E6EEB 22B3B2E5
        "));
        let subgroup_size = boxed_uint_from_be_slice(&hex!("
            F518AA87 81A8DF27 8ABA4E7D 64B7CB9D 49462353
        "));
        let dh_params = DiffieHellmanParams::new(prime.clone(), generator.clone(), subgroup_size.clone());

        let pseudorandom_result = boxed_uint_from_be_slice(&hex!("
            A0C7C50C 002061A5 1CC87D25 4EF38068
            607417B6 EE1B3647 3CFB800D 2D2E5FA2
            B6980F01 105D24FA B22ACD1B FA5C8A4C
            093ECDFA FE6D7125 D42A843E 33860383
            5CF19AFA FF75EFE2 1DC5F6AA 1F9AE46C
            25087E73 68166FB0 8C1E4627 AFED7D93
            570417B7 90FF7F74 7E57F432 B04E1236
            819E0DFE F5B6E77C A4999925 328182D2
        "));
        let mapped_generator = dh_params.derive_integrated_mapping_generator(&pseudorandom_result);
        let expected_generator = boxed_uint_from_be_slice(&hex!("
            1D7D767F 11E333BC D6DBAEF4 0E799E7A
            926B9697 3550656F F3C83072 6D118D61
            C276CDCC 61D475CF 03A98E0C 0E79CAEB
            A5BE2557 8BD4551D 0B109032 36F0B0F9
            76852FA7 8EEA14EA 0ACA87D1 E91F688F
            E0DFF897 BBE35A47 2621D343 564B262F
            34223AE8 FC59B664 BFEDFA2B FE7516CA
            5510A6BB B633D517 EC25D4E0 BBAA16C2
        "));
        assert_eq!(&*mapped_generator, &expected_generator);
    }
}
